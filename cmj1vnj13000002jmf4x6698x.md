---
title: "ğŸš€ Advent of Code Day 11 â€“ Counting Paths Like a Pro"
datePublished: Thu Dec 11 2025 20:15:06 GMT+0000 (Coordinated Universal Time)
cuid: cmj1vnj13000002jmf4x6698x
slug: advent-of-code-day-11-counting-paths-like-a-pro
cover: https://cdn.hashnode.com/res/hashnode/image/upload/v1765484087473/65abefdf-7ff5-4cfc-95ed-6be7736939a3.webp

---

### Memoized DFS, Clean Graph Parsing & High-Performance Path Logic (Pseudocode Only)

When Advent of Code reaches the double digits, problems stop being cute and start becoming *mathematically evil*.  
Day 11 was exactly that â€” a deceptively simple â€œcount all possible pathsâ€ challenge that secretly hides exponential blowâ€‘ups if you approach it naÃ¯vely.

This blog breaks down **the clean, high-performance approach** I used:

* Graph parsing using adjacency lists
    
* Memoized DFS to count paths *without enumerating them*
    
* A smart trick to enforce ordering constraints for Part 2
    
* All expressed in **pseudocode only**, to keep it general and interviewâ€‘friendly
    

Letâ€™s dive deep â€” modular, scalable, interviewâ€‘ready logic.

---

## ğŸ§© Problem Summary

Youâ€™re given a text file where each line represents directed edges:

```plaintext
A: B C D
X: Y
...
```

Meaning:  
`A â†’ B`, `A â†’ C`, `A â†’ D`

Your tasks:

### **Part 1**

Count all possible paths from:

```plaintext
"you" â†’ "out"
```

### **Part 2**

Count all paths from:

```plaintext
"svr" â†’ "out"
```

â€¦but only those that pass through **both**:

```plaintext
"dac" and "fft"
```

in **either order**.

This is exactly the kind of problem where brute-force DFS explodes.  
So we donâ€™t enumerate paths â€” we **count** them mathematically.

---

## ğŸ§  Core Idea: DFS + Memoization

We treat the graph as a DAG-like structure and compute the number of ways to reach the destination using topâ€‘down dynamic programming.

This transforms exponential DFS into near linear-time traversal.

---

## ğŸ› ï¸ Step 1 â€” Parsing Input into an Adjacency List

### **Pseudocode**

```plaintext
function parse(lines):
    graph = empty map of list

    for line in lines:
        if line is blank:
            continue

        left, right = split line at ":"
        src = trim(left)
        dest_nodes = split right by spaces

        graph[src].add_all(dest_nodes)

    return graph
```

This ensures:

* Clean structure
    
* O(1) traversal for children
    
* Perfect input â†’ graph transformation
    

---

## ğŸ› ï¸ Step 2 â€” Counting Paths with Memoized DFS

### **Pseudocode**

```plaintext
function countPaths(graph, start, end, memo):

    if start == end:
        return 1

    if memo has start:
        return memo[start]

    total = 0

    for nxt in graph[start]:
        total += countPaths(graph, nxt, end, memo)

    memo[start] = total
    return total
```

This pattern is gold because:

* Every node is solved once
    
* Overlapping subproblems vanish
    
* No path enumeration required
    
* Scales beautifully even for large graphs
    

---

## ğŸ¯ Part 1 â€” Straight Computation

We simply compute:

```plaintext
paths_you_to_out = countPaths(graph, "you", "out")
```

Done.  
Clear.  
Optimized.  
No drama.

---

## ğŸ¯ Part 2 â€” Enforcing â€œMust Pass Through X and Yâ€

We break the path into segments.

To go from `svr` â†’ `out` while touching `dac` and `fft`, both sequences are possible:

### Order 1:

```plaintext
svr â†’ dac â†’ fft â†’ out
```

### Order 2:

```plaintext
svr â†’ fft â†’ dac â†’ out
```

So compute segment counts:

### **Pseudocode**

```plaintext
a = countPaths(graph, "svr", "dac")
b = countPaths(graph, "dac", "fft")
c = countPaths(graph, "fft", "out")

d = countPaths(graph, "svr", "fft")
e = countPaths(graph, "fft", "dac")
f = countPaths(graph, "dac", "out")
```

Then:

```plaintext
total_valid = a*b*c + d*e*f
```

Thatâ€™s it.  
Zero enumeration.  
Zero wasted computation.  
Mathematically perfect.

---

## ğŸš€ Final Thoughts

This Day 11 solution shines because itâ€™s:

* **Modular** â€“ clean separation of parsing, logic, and DP
    
* **Scalable** â€“ memoized DFS avoids exponential death
    
* **Generalizable** â€“ works for any path-counting DAG problem
    
* **Interview-ready** â€“ demonstrates DP over graphs, ordering constraints, and decomposition
    

Day 11 may have tried to explode your recursion stack â€”  
but with memoization, it never stood a chance.

## ğŸ”— Connect with Me

If you found this structured, algorithmic approach helpful, check out my full AoC repository:

GitHub: RP2025/AdventOfCode

LinkedIn: Raksha Pahariya I post daily breakdowns, clean coding approaches, and Advent of Code fun! Let's connect and share our progress. ğŸš€ğŸ”¥